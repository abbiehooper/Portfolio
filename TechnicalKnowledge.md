# Data Structures & Algorithms

## Data Structures
- [ ] Arrays
- [ ] Lists (ArrayList, List<T>)
- [ ] Linked Lists (LinkedList<T>)
- [ ] Stacks
- [ ] Queues
- [ ] Priority Queues
- [ ] Dictionaries / Hash Tables (Dictionary<TKey, TValue>)
- [ ] HashSet
- [ ] SortedList, SortedDictionary, SortedSet
- [ ] Trees (Binary Trees, Binary Search Trees)
- [ ] Graphs
- [ ] Heaps
- [ ] Tries
- [ ] When to use which data structure

## Algorithms
- [ ] Big O notation (Time and Space complexity)
- [ ] Sorting algorithms (QuickSort, MergeSort, BubbleSort, etc.)
- [ ] Searching algorithms (Binary Search, Linear Search)
- [ ] Recursion vs Iteration
- [ ] Dynamic Programming
- [ ] Greedy algorithms
- [ ] Divide and Conquer
- [ ] Graph traversal (BFS, DFS)
- [ ] String manipulation algorithms
- [ ] Common algorithm patterns

# Databases
- [ ] Relational vs non-relational databases (wide column, key-value pair, document)
- [ ] Indexing
- [ ] Transactions
- [ ] ACID operations
- [ ] Normalization
- [ ] Transaction & Isolation Levels
- [ ] Delete vs Truncate
- [ ] Relations
- [ ] Joins, unions
- [ ] Stored Procedures, Functions
- [ ] Cursor
- [ ] Trigger
- [ ] Query Execution Plan, Caching, Profiler
- [ ] View vs Table
- [ ] Backup
- [ ] Connection pooling
- [ ] SQL injection prevention
- [ ] Database sharding
- [ ] Replication

# DevOps & Infrastructure
- [ ] CI/CD concepts
- [ ] Build pipelines
- [ ] Deployment strategies (Blue/Green, Canary, Rolling)
- [ ] Infrastructure as Code
- [ ] Containerization (Docker)
- [ ] Orchestration (Kubernetes basics)
- [ ] Monitoring and observability
- [ ] Application logging
- [ ] Health checks
- [ ] Environment configuration

# .NET

## Fundamentals
- [ ] string vs StringBuilder
- [ ] List vs Array
- [ ] Generics
- [ ] Reflection
- [ ] Lambda expressions & Linq
- [ ] Action vs Function vs Expression
- [ ] Memory Structure
- [ ] using syntax
- [ ] Caching
- [ ] Dependency Injection
- [ ] Service lifetimes (Singleton, Scoped, Transient)
- [ ] IOptions pattern
- [ ] Value types vs Reference types
- [ ] Garbage Collection
- [ ] IDisposable pattern
- [ ] Nullable types
- [ ] Extension methods
- [ ] Attributes
- [ ] Exception handling
- [ ] Configuration management (appsettings.json, environment variables, user secrets)
- [ ] Logging (ILogger, logging providers)
- [ ] Records vs Classes vs Structs
- [ ] Pattern matching
- [ ] Tuples and deconstruction
- [ ] Delegates and events
- [ ] Middleware pipeline
- [ ] Hosted Services / Background Services
- [ ] Health checks
- [ ] HTTP Client Factory
- [ ] Collections (Dictionary, HashSet, Queue, Stack, etc.)
- [ ] LINQ query syntax vs method syntax
- [ ] Streams, buffers and File I/O

## Threading
- [ ] Async / Await
- [ ] Thread vs Thread pool
- [ ] Thread synchronization
- [ ] Task Parallel Library (TPL)
- [ ] Deadlocks and race conditions
- [ ] Mutexes, semaphores
- [ ] Concurrent collections
- [ ] async/await best practices

## Data Formats
- [ ] JSON
- [ ] CSV/TSV
- [ ] XML
- [ ] YAML

## ORM
- [ ] ORM Solutions: Entity Framework, Nhibernate, Dapper
- [ ] When to Use and When not to Use

## Entity Framework
- [ ] Entity Data Model key concepts
- [ ] Code First vs Database First
- [ ] Validation & Data Annotation
- [ ] Complex types, POCOs
- [ ] Entity SQL, Linq to entities
- [ ] Eager loading, Lazy Loading
- [ ] EF Inheritance
- [ ] IEnumerable vs IQueryable
- [ ] Transactions
- [ ] EF Migration
- [ ] DbContext
- [ ] Change tracking
- [ ] Performance optimization

## ASP.NET / Web Development
- [ ] MVC pattern
- [ ] Web API / REST principles
- [ ] Minimal APIs
- [ ] Middleware
- [ ] Routing
- [ ] Model binding
- [ ] Filters and attributes
- [ ] HTTP methods (GET, POST, PUT, DELETE, PATCH)
- [ ] Status codes
- [ ] CORS
- [ ] Session and state management
- [ ] Razor syntax
- [ ] Blazor (Server vs WebAssembly vs Interactive mode)
- [ ] SignalR (real-time communication)
- [ ] gRPC services
- [ ] OpenAPI / Swagger
- [ ] Request/Response pipeline
- [ ] Model validation
- [ ] Authentication middleware
- [ ] Static files and wwwroot
- [ ] Endpoint routing
- [ ] WebApplicationFactory (integration testing)

# OOP  
- [ ] Polymorphism
- [ ] Inheritance
- [ ] Encapsulation
- [ ] Interfaces vs Abstract Classes
- [ ] Overriding vs Overloading
- [ ] Access modifiers
- [ ] Static vs Instance
- [ ] Variables, properties, fields
- [ ] Globalization, Localization
- [ ] Serialization, Deserialization
- [ ] Class vs. Object
- [ ] Structure vs. Class
- [ ] OOP vs functional programming
- [ ] Abstraction
- [ ] Composition vs Inheritance

# Patterns & Practices
- [ ] Authentication
- [ ] OAuth
- [ ] JWTs
- [ ] Authorization
- [ ] RBAC
- [ ] Fine-grained
- [ ] Design patterns (Singleton, Factory, Strategy, Observer, Decorator, Repository, etc.)
- [ ] Programming principles: SOLID, GRASP, DRY, KISS, YAGNI
- [ ] IOC vs DI. DI vs Service Locator
- [ ] CQRS
- [ ] Basic Architectural patterns: N-Tier, MVC, MVVM
- [ ] Advanced Architectural patterns: Clean Architecture, Domain Model, Service Layer, DTO, Table/Row, Data Mapper, Repository, Unit of Work, Identity Map, Lazy load
- [ ] Event-driven architecture
- [ ] Microservices vs Monolith
- [ ] Domain-Driven Design (DDD)
- [ ] API design best practices

# Performance & Optimization
- [ ] Profiling and benchmarking
- [ ] Memory management
- [ ] Database query optimization
- [ ] Caching strategies
- [ ] Lazy loading vs Eager loading
- [ ] Async patterns for performance
- [ ] Resource pooling

# Security
- [ ] OWASP top 10
- [ ] Authentication vs Authorization
- [ ] HTTPS/TLS
- [ ] Encryption (at rest, in transit)
- [ ] Secrets management
- [ ] Input validation
- [ ] CORS
- [ ] XSS, CSRF, SQL injection
- [ ] Security headers
- [ ] Principle of least privilege

# Soft Skills & Collaboration
- [ ] Code reviews
- [ ] Documentation
- [ ] Technical writing
- [ ] Agile methodologies (Scrum, Kanban)
- [ ] Estimation techniques
- [ ] Pair programming, mob programming
- [ ] Knowledge sharing
- [ ] Asking effective questions
- [ ] Giving and receiving feedback

# System Design
- [ ] CAP theorem, eventual consistency
- [ ] Horizontal vs vertical scaling
- [ ] Latency vs Throughput
- [ ] Protocols (REST, gRPC, GraphQL, SOAP)
- [ ] Load balancing
- [ ] Caching strategies (CDN, in-memory, distributed)
- [ ] Message queues
- [ ] Service discovery
- [ ] API Gateway
- [ ] Circuit breaker pattern
- [ ] Rate limiting
- [ ] Database replication and sharding
- [ ] Consensus algorithms, fault tolerance
- [ ] Idempotency

# Testing
- [ ] Test pyramid: Unit Testing, integration testing, E2E testing, contract testing
- [ ] Setup, teardown methods
- [ ] Mocking
- [ ] Frameworks: nUnit, xUnit
- [ ] Unit tests best practices: FIRST, AAA syntax, Naming
- [ ] Integration testing / Automation Testing
- [ ] Load testing
- [ ] Soak testing
- [ ] Test coverage

# Tools
## Source Control - ADO/Git
- [ ] Concepts: Repository, trunk, revision, changeset
- [ ] Actions: Commit, update, revert
- [ ] lock-modify-unlock vs copy-modify-merge
- [ ] Conflict resolution
- [ ] Branching strategies (GitFlow, trunk-based development)
- [ ] Tagging
- [ ] Distributed version control
- [ ] SVN, CVS, TFS
- [ ] Git/Mercurial
- [ ] Pull requests / Code reviews
- [ ] Merge vs Rebase

## API Testing
- [ ] Postman/Insomnia
- [ ] Request collections
- [ ] Global variables
- [ ] Environment variables
- [ ] Automated API testing

## Other Tools
- [ ] Package managers (NuGet)
- [ ] Build tools (MSBuild, dotnet CLI)
- [ ] IDE features (debugging, profiling, refactoring)
- [ ] SonarQube / Static code analysis

# UX & UI Design Principles
- [ ] User-centered design
- [ ] Accessibility (WCAG guidelines, ARIA, keyboard navigation)
- [ ] Responsive design
- [ ] Mobile-first approach
- [ ] Design systems and component libraries
- [ ] Information architecture
- [ ] Visual hierarchy
- [ ] Typography and readability
- [ ] Color theory and contrast
- [ ] Whitespace and layout
- [ ] Consistency and patterns
- [ ] User feedback and validation
- [ ] Loading states and error handling
- [ ] Form design best practices
- [ ] Navigation and wayfinding
- [ ] Usability testing
- [ ] A/B testing
- [ ] Wireframing and prototyping
- [ ] Design tools (Figma, Adobe XD, Sketch)
- [ ] Brand guidelines and style guides
- [ ] Microinteractions and animations
- [ ] Performance perception (perceived vs actual performance)
- [ ] Progressive enhancement
- [ ] Graceful degradation

# Resources

- System design: https://www.hellointerview.com/learn/system-design/in-a-hurry/introduction
- Data structures and algorithms: https://www.hellointerview.com/learn/code